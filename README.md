# # 前言

本仓库内容根据哔哩哔哩 [《JavaScript 数据结构与算法》](https://www.bilibili.com/video/BV1x7411L7Q7?p=1) 视频整理的学习笔记，视频教程讲的特别好，配合本仓库的代码测试环境来练习，学习效果更佳，欢迎同学们 Star 和 Fork。

推荐大家按照目录顺序来学习，由浅入深，循序渐进，轻松搞定数据结构和算法。

> 重点要掌握数据结构与算法的思想和原理，使用哪种编程语言区别不大。

# 一、什么是数据结构？

## 1. 数据结构的定义

民间定义

- 数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种关系。这些联系可以通过定义相关的函数来给出。 --《数据结构、算法与应用》
- 数据结构是 ADT（抽象数据类型 Abstract Data Type）的物理实现。 --《数据结构与算法分析》
- 数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。 --中文维基百科（*）

自己的角度来理解：

- 数据结构就是在计算机中，存储和组织数据的方式。
- 我们知道，计算机中数据量非常庞大，如何以高效的方式组织和存储数据呢？
- 这就好比一个庞大的图书馆中存放了大量的数据，我们不仅仅把书放进去，还应在合适的位置找出来。

## 2. 数据结构在生活中应用

我们知道，计算机中数据量非常庞大，如何以高效的方式组织和存储呢?

例如：一个庞大的图书馆中存放了大量的书籍，我们不仅仅要把书放进入，还应该在合适的时候能够取出来。

图书摆放要使得两个相关操作方便实现：

- 操作 1：新书怎么插入？
- 操作 2：怎么找到某本指定的书？

图书各种摆放方式：

- 方法 1：随便放
  - 操作 1：哪里有空位放哪里。
  - 操作 2：找某本书，累死。
- 方法 2：按照书名的拼音字母顺序排放
  - 操作 1：新进一本《阿 Q 正传》， 按照字母顺序找到位置，插入。
  - 操作 2：二分查找法。
- 方法 3：把书架划分成几块区域，按照类别存放，类别中按照字母顺序
  - 操作 1：先定类别，二分查找确定位置，移出空位。
  - 操作 2：先定类别，再二分查找。

结论：

- 解决问题方法的效率，根据数据的组织方式有关。
- 计算机中存储的数据量相对于图书馆的书籍来说数据量更大，数据更加多。
- 以什么样的方式，来存储和组织我们的数据才能在使用数据时更加方便呢?
- 这就是数据结构需要考虑的问题。

## 3. 常见的数据结构

![](./IMGS/adt.png)

> 注意：数据结构与算法与语言无关，常见的编程语言都有**直接或间接**的使用上述常见的数据结构。

# 二、什么是算法？

## 1. 算法的定义

算法就是任何 **良定义** 的 **计算过程**，该过程取某个值或者值的集合作为 **输入** 并产生某个值或者值的集合作为 **输出**。

- 一个有限指令集，每条指令的描述不依赖于语言。
- 接收一些输入（有些情况下不需要输入）。
- 产生输出。
- 一定在有限步骤之后终止。

## 2. 算法通俗理解

- Algorithm 这个单词本意就是解决问题的办法/步骤逻辑。
- 数据结构的实现，离不开算法。

## 3. 算法的描述方式

算法可以使用 **自然语言**、**伪代码**、**流程图** 等多种不同的方法来描述。

## 4. 算法五个重要特征

- **有穷性**
  - 算法的有穷性是指算法必须能在执行有限个步骤之后终止;
- **确切性**
  - 算法的每一步骤必须有确切的定义;
- **输入项**
  - 一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
- **输出项**
  - 一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的;
- **可行性**
  - 算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成(也称之为有效性)。

## 5. 算法案例

算法主要用于解决 **排序问题**

假如上海和杭州之间有一条高架线，高架线长度是 1,000,000 米，有一天高架线中有其中一米出现了故障，请你想出一种算法，可以快速定位到出问题的地方。

- 线性查找
  - 从上海的起点开始一米一米的排查，最终一定能找到出问题的线段。
  - 但是如果线段在另一头，我们需要排查 1,000,000 次，这是最坏的情况，平均需要 500,000 次。
- 二分查找
  - 从中间位置开始排查，看一下问题出在上海到中间位置，还是中间到杭州的位置。
  - 查找对应的问题后，再从中间位置分开，重新锁定一般的路程。
  - 最坏的情况，需要多少次可以排查完呢? 最坏的情况是 20 次就可以找到出问题的地方。
  - 怎么计算出来的呢? log(1000000, 2)，以 2 位底，1000000 的对数 ≈ 20。

结论：
你会发现，解决问题的办法有很多，但是好的算法对比于差的算法，效率天壤之别。

## 6. 算法解决哪些问题？

1.  **排序问题**：如插入排序，归并排序，快速排序等。

   排序绝不是已开发算法的唯一计算问题，算法的实际应用无处不在：

2. **背包问题**

   问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？

3. **最长公共子序列**

   最长公共子序列英文缩写为LCS（Longest Common Subsequence）其定义是，一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。

4. **找零钱问题**

   当前有面值分别为2角、1角，5分，1分的硬币，请给出找n分钱的最佳方案（要求找出的硬币数目最少）。

5. ......

# 三、算法分析

## 1. 概念

算法分析是计算机程序 **性能和资源使用情况** 的理论研究。

## 2. 时间复杂度

时间复杂度是指执行这个算法所需要的 **计算工作量（效率）**，其复杂度反映了程序执行时间 **随输入规模增长而增长的量级**，在很大程度上能很好地反映出算法的优劣与否。一个算法花费的时间与算法中语句的 **执行次数成正比**，执行次数越多，花费的时间就越多。一个算法中的执行次数称为**语句频度**或**时间频度**，记为`T(n)`，其中`n`称为问题的规模，当`n`不断变化时，它所呈现出来的规律，我们称之为**时间复杂度**。

**1）运行时间取决下因素**：

- 计算模式：RAM（随机存取存储器）--- 总共有多少计算机？
  - 在RAM模型中，指令被一条接着一条执行，没有并发执行
  - 指令宝行在RAM模式中
- 机器：CPU计算机运行有多快?
- 输入：实例的规模有多少数据?
- 要做的基本操作的数量（次数）

**2）计算运行时间**

- 输入：           输入数据类型              `I`
- 输入规模：   多少数据？                  `b = |I|`
- 机器：CPU   机器运行多快？           `v1, ... , vk`
- 计算模式：RAM（随机存取存储器）有多少个机器？只有一个
- **保证**：逐渐地，就运行时间我们寻找一个上界，因为每个人都想要一个保证最大值
- 运行时间由以下决定：要做的基本操作数量和CPU的速度
- 运行时间：`t = sum{ n1/v1 + ... + nk/vk }`

**3）运行时间：机器无关性运行时间**

- `t = sum{ n1/v1 + ... + nk/vk }`
- `t = sum{ n1 + ... + nk } / v` 假设 `vi=v`（不变，即假设每台机器CPU运行速度一样快）
- `t =c×sum{ n1 + ... + nk }`
- `t ~ sum{ n1 + ... + nk }` 机器无关性
  -  忽略机器相关性常量
  - 时间复杂度: 简化的运行时间

$$
T = sum \{ n1 + ... + nk \} -- 基本操作的总数
$$

比如：
$$
T(n)=n^21?tex=T(n)=n^21
$$
与
$$
T(n)=5n^22n1?tex=T(n)=5n^22n1
$$

虽然算法的时间频度不一样，但他们的时间复杂度却是一样的，**时间复杂度只关注最高数量级，且与之系数也没有关系**。通常一个算法由控制结构（顺序，分支，循环三种）和原操作（固有数据类型的操作）构成，而算法时间取决于两者的综合效率。

**4）更加简化的时间复杂度**

- 最坏情况: （通常情况下）
  - 最坏情况下的时间复杂度称最坏时间复杂度。最坏情况即对规模为`n`的任何输入，算法的最长运行时间。
  - 一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。
  - 例如在最坏情况下的时间复杂度为 `T(n)=0(n)`，它表示对于任何输入实例，该算法的运行时间不可能大于 `0(n)`。
- 平均情况：
  - `T(n)` = 所有输入为`n`时，算法的预期执行时间。
  - 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。
  - 需要对输入值的统计分布情况进行假设。
- 最好情况：（几乎不可能）
  - 用一个某些情况下工作比较快实际上比较慢的算法进行欺骗。

## 3. 空间复杂度

一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。

程序执行时所需存储空间包括以下两部分。　　

（1）固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。

（2）可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。

一个算法所需的存储空间用 `f(n)` 表示
$$
S(n) = O(f(n))
$$
其中 `n` 为问题的规模（或大小），`S(n)` 表示空间复杂度

>  ！Tips：通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为 `0(1)`。一个一维数组 `a[n]`，空间复杂度 `O(n)`，二维数组为`O(n^2)`。

## 4. 大O表示法

通过“大O”标识符 <u>粗略</u> 估算时间复杂度。

函数渐近增长推导大O阶的表示法有以下几个规则可以用使用:

- 用常数1取代运行时间中的所有加法常数；
- 在修改后运行次数中，只保留高阶项；
- 如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数；



**常见大O阶**

![](.\IMGS\big-o.jpg)

下面是对常见时间复杂度的一个总结：

| 描述         | 增长的数量级 | 说明     | 举例           |
| ------------ | ------------ | -------- | -------------- |
| 常数级别     | $1$          | 普通语句 | 将两个数相加   |
| 对数级别     | $log(n)$     | 二分策略 | 二分查找       |
| 线性级别     | $n$          | 循环     | 找出最大元素   |
| 线性对数级别 | $nlog(n)$    | 分治思想 | 归并排序       |
| 平方级别     | $n^2$        | 双层循环 | 检查所有元素对 |
| 立方级别     | $n^3$        | 三层循环 | 检查所有三元组 |
| 指数级别     | $2^n$        | 穷举查找 | 检查所有子集   |

时间复杂度从低到高一次为：
$$
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3)
$$

## 4. 算法的简单性与最优性

**1）简单性**

- 含义：算法简单；程序结构简单
- 好处：容易验证程序正确性；便于程序调试

> ！Tips：简单的算法效率不一定高，要保证一定效率的前提下力求得到见到的算法。

**2）最优性**

- 含义：指求解某类问题中效率最高的算法。
- 我们说：在最坏情况下，如果没有其他我们学过的算法比这个算法执行更少的基本步骤，那么这个算法就是最优的。

**3）两种最优性**

- 最坏情况下最优：

  设A是解某个问题的算法，如果在解这个问题的算法类中没有其他算法在最坏情况下的时间复杂性比A在最坏情况下的时间复杂性低，则称A是解这个问题在最坏情况下的最优算法。

- 平均情况下最优：

  设A是解某个问题的算法，如果在解这个问题的算法类中没有其他算法在平均情况下的时间复杂性比A在平均情况下的时间复杂性低，则称A是解这个问题在平均情况下的最优算法。
